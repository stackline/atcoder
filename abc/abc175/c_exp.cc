#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
  ll x, k, d;
  cin >> x >> k >> d;

  // x を正の座標にする
  x = abs(x);

  // x 座標から 0 に向かって移動可能な回数を算出する
  //
  // * 移動回数は基本 x/d 回だが、k < x/d の場合は k となる
  // * 0 を超えてマイナスには移動しない
  // * 最大でも座標 0 に着地する
  //   * 例えば x = 8, d = 4, k = 100 の場合
  //   * x/d = 8/4 = 2 で、2回 -4 側に移動し、x=0 に着地する
  //
  ll straight = min(k, x/d);

  // 座標と回数を変化させる
  k = k - straight;
  x = x - (straight * d);

  // 残りの移動回数が偶数回の場合
  //
  // * 移動して戻ってくるを繰り返すことで、現在の座標に留まることが、最小値となる
  // * 0の場合も同様
  //
  if (k % 2 == 0) {
    cout << x << endl;
  // 残りの移動回数が奇数回の場合
  //
  // * k = 0 のケース
  //   * min(k, floor(x/d)) == k だった
  //     * 移動回数の上限が少なく、x が 0 に到達する (あるいは 0 を通り抜ける) 前に、回数上限に達する
  //   * min(k, floor(x/d)) == k ( == floor(x/d))
  //     * 移動回数の上限と、x が 0 に到達する (あるいは 0 を通り抜ける) 回数が一致
  // * k > 0 のケース
  //   * min(k, floor(x/d)) == floor(x/d)
  //   * つまり k 回移動する前に、floor(x/d) 回の移動で、x が 0 付近に到達する
  //   * この際、移動先の座標は d 未満となる
  //     * 逆に座標が d 以上の場合は floor(x/d) で移動回数を算出する時点で、移動回数が +1 される
  //   * そのため、x < d のため、d - x > 0 となり、正の値を出力する
  //
  } else {
    cout << d-x << endl;
  }

  return 0;
}
