#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// 真ん中のブロックを取り除いて半分にする
//
// 取り扱う数字が大きいため、事前に剰余を算出する。
// mod P を取るため、算出した面積の数字を2で割ることができない。
// そのため、逆元を用いて、割り算の代わりに掛け算を使って、剰余を求める。
//
// これは和・差・積は最後に mod を取るのと、各演算ごとに mod を取るのとで結果が一致するためである。
//
int main() {
  int n;
  cin >> n;
  vector<ll> a(n);
  ll sum = 0;
  int mod = 1000000007;

  for (int i = 0; i < n; i++) {
    cin >> a.at(i);
    sum = sum + a.at(i);
    sum = sum % mod;
  }

  // sum = 正方形の縦軸 または 横軸の長さ
  // sum * sum = 正方形の全体の面積
  // 和・差・積は最後に mod を取るのと、各演算ごとに mod を取るのとで結果が一致する
  ll ans = (sum * sum) % mod;

  // 中央の正方形を取り除く
  for (int i = 0; i < n; i++) {
    //
    // * Ai <= 10**9 のため Ai * Ai < 2**64 となり、long long 型で保持できる
    // * この時点で mod 同士の引き算となる
    // * A mod M - B mod M = (A-B) mod M より、(sum * sum - a.at[i] * a[i]) mod M と同様である。
    //
    ans = ans - (a.at(i) * a.at(i) % mod);
    //
    // ans が負の数になった場合は、除数 p を加算して正の数にする
    //
    // ### 例
    //
    // n = -1, p = 3 の場合 n mod p = -1 mod 3 = -1 となる。
    // これに除数を複数回、加算する。
    //
    // # 1回
    // (n+p) mod p = (-1 + 3) mod 3 = 2 mod 3 = 2
    // # 2回
    // (n+p+p) mod p = (-1 + 3 + 3) mod 3 = 5 mod 3 = 2
    // # 3回
    // (n+p+p+p) mod p = (-1 + 3 + 3 + 3) mod 3 = 8 mod 3 = 2
    //
    // これらより、被除数が正の数になった後、除数を加算しても余りの数は変わらない。
    // 被除数が負の数から正の数になった場合、余りの数は |除数 - 被除数| の値となる。
    //
    if (ans < 0) { ans += mod; }
  }

  // この時点の ans は、大きい正方形から中央の正方形を取り除いた面積の mod 10**9+7 の剰余の数である。
  // 面積の半分を求めたいので 2 で割りたいが、ans が剰余の数であるため、2で割ることができない（結果がズレる可能性があるため）
  //
  // そのため、逆元を用いる。
  // 一般的な式は以下である。
  //
  //   (a/b) = a * (1/b) (mod 10**9+7)
  //   (a/b) = a * b**-1 (mod 10**9+7)
  //
  // これを今回の変数に当てはめる。
  //
  //   (ans/2) = ans * (2**-1) (mod 10**9+7)
  //
  // (mod 10**9+7) での 2 の逆元を求める。
  // つまり 2 * 2**-1 = 1 となる 2**-1 を求める。
  //
  //       2 * 2**-1
  //   --> 2 * ((10**9+7 + 1) / 2) (mod 10**9+7)
  //   --> (10**9+7 + 1) (mod 10**9+7)
  //   --> 剰余の数は 1 となる
  //
  // つまり、mod P において x の逆元は ((P+1) / x) となる。
  //
  //   x * (((P+1)) / x) (mod P)
  //   = (P+1) (mod P)
  //   = 剰余の数は1となる
  //
  ans = ans * ((mod + 1) / 2);
  ans = ans % mod;

  cout << ans << endl;
  return 0;
}
