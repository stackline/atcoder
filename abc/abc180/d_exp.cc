#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// endl: line break + buffer flush
// '\n': line break
// cout << fixed << setprecision(15);
// printf("%.15f\n", sqrt(ans));
int main() {
  cin.tie(nullptr); // Do not flush "cout" when processing "cin".
  // ios::sync_with_stdio(false); // Do not use both "cin/cout" and "scanf/printf" at the same time.

  ll x, y, a, b;
  cin >> x >> y >> a >> b;

  ll ans = 0;

  // ##### (double)x * a <= 1e18
  //
  // 入力例を以下とする。
  //
  //   x = 1000000000000000000 // 10**18
  //   y = 1000000000000000000 // 10**18
  //   a = 1000000000 // 10**9
  //   b = (任意の値)
  //
  // while 内の判定条件 (x * a < y) について、
  // 左辺がオーバーフローし、判定が意図しない結果となる。
  //
  //   x * a < y
  //   1000000000000000000 * 1000000000 < 1000000000000000000
  //   -6930898827444486144 < 1000000000000000000
  //
  // x * a = 10**18 * 10**9 = 10**27 である。
  //
  // ### (signed) long long 型の取り扱える最大の数
  //
  // (2**64 / 2 - 1) であり、10のべき乗でおおよその範囲を表すと以下となる。
  //
  //   10**18 < (2**64 / 2 - 1) < 10**19
  //
  // (2**64 / 2 - 1) < 10**19 < 10**27 から、オーバーフローする。
  //
  // ### double 型の取り扱える最大の数
  //
  // 約1.79 * 10**308 である。
  // 約1.79 * 10**308 > 10**27 から、オーバーフローしない。
  //
  // ### (double)x * a <= 1e18
  //
  // 左辺はオーバーフローを回避するため double 型にキャストしている。
  //
  // 右辺は指数表記であり、suffix を指定しない場合は
  // デフォルトで double 型となる。
  //   ref. https://en.cppreference.com/w/cpp/language/floating_literal
  // y の最大値は 10**18 であるため、右辺は 1e18 を指定している。
  //
  // 回答では右辺に 2e18 を指定している。
  // これは long long 型で取り扱える範囲に収まる、
  // かつ double 型の誤差発生を考慮した結果かもしれない。
  //
  // ##### x * a <= x + b
  //
  // 強さが y 以上になるまで、カコモンジムに通い続けるパターンを探索する。
  //
  // 探索の途中で、カコモンジムより AtCoder ジムに通う方が、
  // 「強さ」の増加が低くなる状況がある。
  //
  // この状況に到達すると、AtCoder ジムに通う方が
  // 「強さ」の増加が抑えられるため、ジムに通える回数が多く、
  // 経験値を増やすことができる。
  //
  // ### 入力例2の場合
  //
  // x = 1
  // y = 1000000000000000000
  // a = 10
  // b = 1_000_000_000
  //
  // カコモンジムに9回通った時点で、強さは 10**9 となる。
  //
  //   x * a**9 = 1 * 10**9 = 1_000_000_000
  //
  // この状況でカコモンジムと AtCoder ジムに1回通った後の強さは、
  // それぞれ以下となる。
  //
  //   [カコモンジム]
  //   10**9 * a
  //   = 10**9 * 10
  //   = 10**10
  //
  //   [AtCoder ジム]
  //   10**9 + b
  //   = 1_000_000_000 + 1_000_000_000
  //   = 2_000_000_000
  //   = 10**9 * 2
  //
  // AtCoder ジムに通った後、カコモンジムに通うパターンは、
  // その逆より強さが増加してしまうため、
  // カコモンジムに最初に通うパターンを考える。
  //
  // カコモンジムに通いつつ、カコモンジムより AtCoder ジムの方が
  // 強さの増加割合が低くなった時点で、AtCoder ジムに切り替える。
  //
  while ((double)x * a <= 1e18 && x * a < y && x * a <= x + b) {
    x *= a;
    ans++;
  }

  // カコモンジムに通える最大の回数 ans と
  // AtCoder ジムに通える最大の回数の和を出力する。
  //
  // (y - x) / b とせず、分子を -1 しているのは、
  // 「強さが Y 以上にならないように」するため。
  // 最大でも y - 1 以下になるような AtCoder にジムに通える
  // 最大の回数を求める。
  cout << ans + (y - 1 - x) / b << endl;
  return 0;
}
