#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// ### 移動A
// * a+b = c+d
// * 左上から右下に伸びる斜線上の移動
//
// ### 移動B
// * a-b = c-d
// * 左下から右上に伸びる斜線上の移動
//
// ### 移動C
// * |a-c| + |b-d| <= 3
// * マス (a,b) を中心に3マス以内の移動
int main() {
  cin.tie(nullptr); // Do not flush "cout" when processing "cin".

  int r1, c1, r2, c2;
  cin >> r1 >> c1 >> r2 >> c2;

  int r = r2 - r1;
  int c = c2 - c1;
  // 最大でも3手で任意のマスに移動できるため、初期値を 3 とする
  int ans = 3;

  // ### 0手で移動できるかどうか
  // * (r1,c1) と (r2, c2) が同一マスである
  if (r == 0 && c == 0) {
    ans = 0;
  }
  // ### 1手で移動できるかどうか
  // * 移動A、移動B、移動Cのいずれかを満たす。
  // * 移動Aを式変形すると a+b = c+d から c-a = -(d-b)
  // * 移動Bを式変形すると a-b = c-d から c-a = +(d-b)
  // * これらより、以下の条件となる。
  if (r == -c || r == c || abs(r) + abs(c) <= 3) {
    ans = 1;
  }
  // ### 2手で移動できるかどうか
  // 移動A + 移動A
  // * 1手で移動できるため除外
  //
  // 移動B + 移動B
  // * 1手で移動できるため除外
  //
  // 移動C + 移動C
  // * マンハッタン距離が6以下かどうか
  if (abs(r) + abs(c) <= 6) {
    ans = 2;
  }
  // パリティが等しい任意のマス
  // * スタート地点のマス (a,b) について x 座標と y 座標の値を合計し
  //   その値が偶数か奇数かを求める。
  // * ゴール地点のマス (c,d) について、x 座標と y 座標の値を合計し
  //   その値の偶奇が、スタート地点のマスの偶奇と一致しているようなマス。
  // * 例
  //   * (a,b) = (2,2) とする。
  //     * 合計値は 2+2 = 4 で偶数である。
  //   * (c,d) = (3,5) の場合
  //     * 合計値は 3+5 = 8 で偶数であり、パリティが等しい。
  //   * (c,d) = (3,6) の場合
  //     * 合計値は 3+6 = 9 で奇数であり、パリティが等しくない。
  //
  // 移動A + 移動B
  // * スタート地点とゴール地点のパリティが等しい場合、2手で移動できる
  // * スタート地点とゴール地点のパリティが等しい場合
  //   * パリティが等しくなるパターン
  //     * r1+c1 = 偶数 かつ r2+c2 = 偶数
  //     * r1+c1 = 奇数 かつ r2+c2 = 奇数
  //   * パリティが等しい場合 r1+c1+r2+c2 の取りうる偶奇
  //     * 偶数 + 偶数 = 偶数
  //     * 奇数 + 奇数 = 偶数
  //   * パリティが等しい場合 r1+c1+r2+c2 は偶数となり 2 で割り切れる
  // * スタート地点とゴール地点のパリティが等しくない場合
  //   * 例: スタート地点 (1,1)、ゴール地点 (4,3) の場合
  //     * r1+c1 = 奇数 + 奇数 = 偶数 (2)
  //     * r2+c2 = 偶数 + 奇数 = 奇数 (7)
  //     * r1+c1+r2+c2 = 偶数 + 奇数 = 奇数 (9)
  //   * パリティが等しくない場合 r1+c1+r2+c2 は奇数となり 2 で割り切れない
  //
  // ### (r ^ c ^ 1) & 1
  // * データ例
  //   * (a,b) = (2,2)、(c,d) = (7,3) とする。
  //   * r = r2 - r1 = 7 - 2 = 5 (0101)
  //   * c = c2 - c1 = 3 - 2 = 1 (0001)
  // * (r ^ c ^ 1) & 1 を計算する
  //   * ^ = XOR (排他的論理和)
  //
  //     0101 (5)
  // XOR 0001 (1)
  // --------
  //     0100
  // XOR 0001 (1)
  // --------
  //     0101
  // AND 0001 (1)
  // --------
  //     0001
  //
  // * パリティが等しいマス場合
  //   * (a,b) = (奇数, 奇数), (c,d) = (奇数, 奇数)
  //     * r = 奇数 - 奇数 = 偶数
  //     * c = 奇数 - 奇数 = 偶数
  //   * (a,b) = (奇数, 奇数), (c,d) = (偶数, 偶数)
  //     * r = 偶数 - 奇数 = 奇数
  //     * c = 偶数 - 奇数 = 奇数
  //   * (a,b) = (偶数, 偶数), (c,d) = (偶数, 偶数)
  //     * r = 偶数 - 偶数 = 偶数
  //     * c = 偶数 - 偶数 = 偶数
  //   * (a,b) = (奇数, 偶数), (c,d) = (奇数, 偶数)
  //     * r = 奇数 - 奇数 = 偶数
  //     * c = 偶数 - 偶数 = 偶数
  //   * (a,b) = (奇数, 偶数), (c,d) = (偶数, 奇数)
  //     * r = 偶数 - 奇数 = 奇数
  //     * c = 奇数 - 偶数 = 奇数
  //   * パリティが等しいマスの場合 r と c の偶奇が一致する。
  // * (r ^ c ^ 1) & 1
  //   * r と c がともに奇数の場合
  //     * 1ビット目のフラグが 1 のため r ^ c = 1 ^ 1 = 0 となる。
  //   * r と c がともに偶数の場合
  //     * 1ビット目のフラグが 0 のため r ^ c = 0 ^ 0 = 0 となる。
  //   * これらより r と c がともに同じ偶奇の場合
  //     * r ^ c ^ 1 = 0 ^ 1 = 1 となる。
  //     * 1 & 1 = 1
  //
  // (r ^ c ^ 1) & 1 = 1 と判定した場合、
  // r と c の偶奇は偶数 or 奇数で一致する。
  // r と c の偶奇が一致する場合、(a,b) と (c,d) のパリティは等しい。
  // (a,b) と (c,d) のパリティが等しい場合、移動A + 移動B の2手で
  // 移動可能である。
  //
  if ((r1 + c1 + r2 + c2) % 2 == 0) {
    ans = 2;
  }
  // 移動A + 移動C
  // * スタート地点を (a,b)、ゴール地点を (c,d) とする。
  // * 移動Aのみ行う場合、スタート地点とゴール地点は以下の式を満たす。
  //   * a+b = c+d
  //   * (a+b) - (c+d) = 0
  // * 移動A + 移動Cを行う場合、移動Cで1マス以上3マス以下の移動を行う。
  //   * 移動Aで移動したマスから x 座標 or y 座標に移動する。
  //     * 正の方向に +1 〜 +3 移動
  //     * 負の方向に -1 〜 -3 移動
  //   * 2地点 (a,b) と (c,d) について「x座標とy座標の和」は
  //     最大で3以下の差を持つ。
  //   * |(a+b) - (c+d)| <= 3
  if (abs((r1 + c1) - (r2 + c2)) <= 3) {
    ans = 2;
  }
  // 移動B + 移動C
  // * スタート地点を (a,b)、ゴール地点を (c,d) とする。
  // * 移動Bのみ行う場合、スタート地点とゴール地点は以下の式を満たす。
  //   * a-b = c-d
  //   * (a-b) - (c-d) = 0
  // * 移動B + 移動Cを行う場合、移動Cで1マス以上3マス以下の移動を行う。
  //   * 移動A + 移動C と同様に、2地点 (a,b) と (c,d) について、
  //     「x座標とy座標の和」は最大で3以下の差を持つ。
  //   * |(a-b) - (c-d)| <= 3
  if (abs((r1 - c1) - (r2 - c2)) <= 3) {
    ans = 2;
  }

  cout << ans << endl;
  return 0;
}
