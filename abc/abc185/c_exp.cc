#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// ### 全探索
// * 計算量は O(L**12)
// * L = 4〜5 が上限
//   * 4**12 < 10**8 < 5**12
// * 一方で L の制約は 12 <= L <= 200 のため TLE する。
ll exhaustiveSearch(ll L) {
  ll cnt = 0;
  // clang-format off
  for (int a = 1; a <= L; a++) {                                                                     // a=1
    for (int b = 1; b <= (L - a); b++) {                                                             // b=2
      for (int c = 1; c <= (L - a - b); c++) {                                                       // c=3
        for (int d = 1; d <= (L - a - b - c); d++) {                                                 // d=4
          for (int e = 1; e <= (L - a - b - c - d); e++) {                                           // e=5
            for (int f = 1; f <= (L - a - b - c - d - e); f++) {                                     // f=6
              for (int g = 1; g <= (L - a - b - c - d - e - f); g++) {                               // g=7
                for (int h = 1; h <= (L - a - b - c - d - e - f - g); h++) {                         // h=8
                  for (int i = 1; i <= (L - a - b - c - d - e - f - g - h); i++) {                   // i=9
                    for (int j = 1; j <= (L - a - b - c - d - e - f - g - h - i); j++) {             // j=10
                      for (int k = 1; k <= (L - a - b - c - d - e - f - g - h - i - j); k++) {       // k=11
                        for (int l = 1; l <= (L - a - b - c - d - e - f - g - h - i - j - k); l++) { // l=12
                          if (a + b + c + d + e + f + g + h + i + j + k + l == L) {
                            cnt++;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  // clang-format on
  return cnt;
}

// ### 組み合わせ
//
// 「分割位置の候補と、余った長さ」を1列に並べる重複組合せと捉えて、
// k = (L - 12) とすると、オーバーフローして不正解 (WA) となる。
//
// ## データ例: L = 200
// * k = 11 とする場合
//   * 解説の「順次割りながら計算する」ことで、オーバーフローしない。
// * k = L - 12 = 188 とする場合
//   * 解説の「順次割りながら計算する」ことをしても、途中でオーバーフローする。
// * 以下の計算結果例では、ループの13回目の計算で signed long long 型が取り扱う
//   データ範囲を超える。
//
// ```sh
// irb(main):007:0> (199/1)*(198/2)*(197/3)*(196/4)*(195/5)*(194/6)*(193/7)*(192/8)*(191/9)*(190/10)*(189/11)
// => 344198613016177920
//
// irb(main):009:0> (199/1)*(198/2)*(197/3)*(196/4)*(195/5)*(194/6)*(193/7)*(192/8)*(191/9)*(190/10)*(189/11)*(188/12)
// => 5162979195242668800
//
// irb(main):008:0> 2**63
// => 9223372036854775808
//
// irb(main):010:0> (199/1)*(198/2)*(197/3)*(196/4)*(195/5)*(194/6)*(193/7)*(192/8)*(191/9)*(190/10)*(189/11)*(188/12)*(187/13)
// => 72281708733397363200
// ```
//
// ざっと確認すると、今回の問題で k = L - 1 で組み合わせを計算する場合、
// L = 62 以下の場合、オーバーフローが発生しない。
// L = 63 以上の場合、オーバーフローが計算途中で発生する。
//
// ### k = 11, L = 200 の時に取り扱う最大の数
//
// 計算途中の式と計算結果は以下となる。
//
// ```
//                 1 * 199 /  1 = 199
//               199 * 198 /  2 = 19701
//             19701 * 197 /  3 = 1293699
//           1293699 * 196 /  4 = 63391251
//          63391251 * 195 /  5 = 2472258789
//        2472258789 * 194 /  6 = 79936367511
//       79936367511 * 193 /  7 = 2203959847089
//     2203959847089 * 192 /  8 = 52895036330136
//    52895036330136 * 191 /  9 = 1122550215450664
//  1122550215450664 * 190 / 10 = 21328454093562616
// 21328454093562616 * 189 / 11 = 366461620334848584
// ```
//
// 上記より
//
// * 199C11 = 366461620334848584
// * 21328454093562616 * 189 / 11 = 366461620334848584
//
// これらより 199C11 を算出するために左辺を 11 で割る前の数が最大である。
// その値が 199C11 * 11 となる。
//
// * 21328454093562616 * 189 / 11 = 199C11
// * 21328454093562616 * 189 = 199C11 * 11
//
// また 21328454093562616 * 189 は 2**63 以下であるため、オーバーフローしない。
//
// ```
// irb(main):001:0> 21328454093562616 * 189
// => 4031077823683334424
// irb(main):004:0> 2**63
// => 9223372036854775808
// irb(main):005:0> 21328454093562616 * 189 < 2**63
// => true
// ```
//
ll combination(ll n, ll k) {
  ll num = 1;
  for (ll i = 1; i <= k; i++) {
    // printf("%lld * %lld / %lld = %lld\n", num, (n - i + 1), i, num * (n - i + 1) / i);
    num = num * (n - i + 1) / i;
  }
  return num;
}

int main() {
  cin.tie(nullptr); // Do not flush "cout" when processing "cin".

  ll L;
  cin >> L;

  // 全探索
  // cout << exhaustiveSearch(L) << endl;

  // 組み合わせ
  // k=11 の場合 AC する。k=L-12 の場合、オーバーフローして WA する。
  ll n = L - 1; // 分割する位置の候補
  ll k = 11;    // 候補から11箇選ぶ
  cout << combination(n, k) << endl;
  return 0;
}
