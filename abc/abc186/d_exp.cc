#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// 計算量 : sort で O(nlog2(N))
int main() {
  cin.tie(nullptr); // Do not flush "cout" when processing "cin".

  int n;
  cin >> n;
  vector<ll> a(n);
  for (int i = 0; i < n; i++) {
    cin >> a.at(i);
  }

  sort(a.begin(), a.end());

  // ### 解説を読んだ際のメモ
  //
  // A1, A2, ..., An について、各要素ごとの差の絶対値を漏れなく加算できれば
  // sort しても問題ない。
  //
  // 昇順に sort すると i < j について、|Ai - Aj| = Aj - Ai となる。
  //
  // 左の数列と右の数列が等しくなる。
  //
  //     N                 N
  //   sigma |Ai - Aj| = sigma (Aj - Ai)
  //   j=i+1             j=i+1
  //
  // 右辺の数列について Aj と Ai を分ける。
  //
  //     N
  //   sigma (Aj) - (N - i) Ai
  //   j=i+1
  //
  // ### 入力例2の例
  //
  // sort 前のA
  //
  //   A = {31, 41, 59, 26, 53}
  //
  // sort 後のA
  //
  //   A = {26, 31, 41, 53, 59}
  //
  // N=5, i=1 の場合、上の式より、以下の計算となる。
  //
  //     (A2 + A3 + A4 + A5) - (5 - 1) * A1
  //   = (31 + 41 + 53 + 59) - 4 * 26
  //   = 184 - 104
  //   = 80
  //
  // これは i=1 の時、つまり Ai = 26 の時の、
  // (31 - 26), (41 - 26), (53 - 26), (59 - 26) の和である。
  //
  //            31 - 26 =  5
  //         41    - 26 = 15
  //      53       - 26 = 27
  //   59          - 26 = 33
  //
  //         41    - 31 = 10
  //      53       - 31 = 22
  //   59          - 31 = 28
  //
  //      53       - 41 = 12
  //   59          - 41 = 18
  //
  //   59          - 53 =  6
  //   ---------------------
  //                合計 176
  //
  // A2 〜 A5 の和は、累積和を予め計算することで、O(1) で求められる。
  // そのため、for loop の計算回数は n-1 回となる。
  //
  // ### 以下の for 文について
  //
  // ある値 A1 〜 An が Aj 側・Ai 側として登場する回数を計算し、
  // その差の値を求めている。
  //
  //   i=1
  //     (31 * 1) - 26
  //   = 5
  //
  //   i=2
  //     (41 * 2) - (26 + 31)
  //   = (41 - 26) + (41 - 31)
  //   = 25
  //
  //   i=3
  //     (53 * 3) - (26 + 31 + 41)
  //   = (53 - 26) + (53 - 31) + (53 - 41)
  //   = 61
  //
  ll ans = 0;
  ll right = 0;
  for (int i = 1; i < n; i++) {
    ll left = a.at(i) * i;
    right += a.at(i - 1);
    ans += left - right;
  }

  cout << ans << endl;
  return 0;
}
