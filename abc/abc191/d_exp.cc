#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll in() {
  double x;
  cin >> x;
  x *= 10000;
  // round で引数 x を最も近い整数に丸める
  return round(x);
}

bool ok(ll dx, ll dy, ll z) {
  // 三角比の斜めが、半径の長さより短いこと
  return dx * dx + dy * dy <= z * z;
}

ll f(ll x, ll y, ll z, ll lim) {
  int l = 0;
  int r = 1;
  ll res = 0;

  // * |y| <= 10**5
  // * y は小数第4位まで与えられる
  // * 誤差回避のため、予め入力値を 10000 倍している
  //
  // これらより、y 座標の取りうる最大値は 1e9
  //
  //   10**5 * 10000
  //   = 10**5 * 10**4
  //   = 10**9
  //   = 1e9
  for (int i = int(1e9) + 50000; i >= lim; i = i - 10000) {
    // left
    while (ok(x - (l * 10000), i - y, z)) {
      l--;
    }
    // right
    while (ok((r * 10000) - x, i - y, z)) {
      r++;
    }
    // l,r は格子点の座標を見つけると、それぞれ左右に移動する。
    // 逆に格子点の座標が見つからない場合、l,r は左右に移動しない。
    // l,r の移動した距離から、格子点の数を数える。
    //
    //   left  に移動した距離 = 0 - l
    //   right に移動した距離 = r - 1
    //
    // これらより (0 - l) + (r - 1) = r - l - 1 が、
    // 探索結果の格子点の数となる。
    res += r - l - 1;
  }
  return res;
}

int main() {
  cin.tie(nullptr); // Do not flush "cout" when processing "cin".

  ll x = in();
  ll y = in();
  ll z = in();

  // ### 入力例3の場合
  // x = 42782.4720
  // y = 31949.0192
  // r = 99999.99
  //
  // x,y を 10000 倍する。
  //
  //   x = 427824720
  //   y = 319490192
  //
  // x,y を 10000 で割った余りを求める。これを中心座標とする。
  //
  //   x = 4720 ... (a)
  //   y =  192 ... (b)
  //
  // ### メモ
  //
  // 入力例3の中心座標は、格子点 (x,y) = (42782, 31949) から
  // x 軸の正の方向に 0.4720、y 軸の正の方向に 0.0192 移動した位置に存在する。
  //
  // 格子点 (0,0) から x 軸の正の方向に 0.4720、
  // y 軸の正の方向に 0.0192 移動した位置に、中心座標を移動させる。
  //
  // 今回、小数の誤差発生を避けるため 10000 倍しているため、
  // (a) (b) について (x,y) = (4720, 192) としている。
  //
  x %= 10000;
  y %= 10000;

  // 「1e9 + 50000」から「10000」に、y 座標を下げながら探索する
  ll ans1 = f(x, y, z, 10000);
  // 中心点を (x,y) = (4720, 192) から (4720, -192) に移動させた後、
  // 「1e9 + 50000」から「0」に、y 座標を下げながら探索する。
  //
  // これは、(x,y) = (4720, 192) を中心点として、y 座標について「-1e9 - 50000」から
  // 「0」まで探索する処理を、x 軸を中心に反転させている。
  //
  //   中心点を (x,y) = (4720, -192) に反転させる。
  //   「1e9 + 50000」から「0」に、y 座標を下げながら探索する。
  //
  // 1回目の探索では「1e9 + 50000」〜「10000」を探索していた。
  // 2回目の探索では「-1e9 - 50000」〜「0」を探索することで、重複なく格子点を探索している。
  //
  ll ans2 = f(x, -y, z, 0);
  cout << (ans1 + ans2) << endl;
  return 0;
}
