#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// ### mod p の和・差・積は、余りを取るタイミングが異なっても、結果が同じである
//
// * 最後に余りを取る場合
//   * (12345678900000 * 100000) % 1000000007 = 358024833
// * 最初に余りを取る場合
//   * (12345678900000 % 1000000007) = 678813585
//   * 678813585 * 100000 = 67881358500000
//   * 67881358500000 % 1000000007 = 358024833
//
// ### mod p の商は、余りを取るタイミングが異なると、結果が異なる
//
// * 最後に余りを取る場合
//   * (12345678900000 / 100000) % 1000000007 = 123456789
// * 最初に余りを取る
//   * (12345678900000 % 1000000007) = 678813585
//   * (678813585 / 100000) = 6788
//   * 6788 % 1000000007 = 6788
//
// ### a / b (mod p) について、mod p の和・差・積と同様に、結果が異ならないように計算する
//
// データ例を以下とする
//
//   a = 678813585
//   b = 100000
//
// つまり以下を計算したい
//
//   678813585 / 100000 (mod 1000000007)
//
// a,b で考えると、以下が成立する (= は合同を表す)
//
//   (a / b) = a * (1 / b) (mod p)
//   (a / b) = a * b**-1 (mod p)
//
// b**-1
//
//   * ビー・インバースと読む
//   * 「b**-1」とは、mod p における「b の逆元」である
//   * 「b の逆元」とは、mod p において b を掛けると 1 になる数である
//   * つまり b * b**-1 = 1 (mod p) を満たす数である
//
// これらより
//
//   * 逆元を使うと、mod p の割り算を mod p の掛け算に変換して、余りを取ることができる
//   * 前提として mod p の掛け算は、余りを取るタイミングが異なっても、結果が同じである
//   * 前提として mod p の割り算は、余りを取るタイミングが異なると、結果が異なるケースがある
//
// mod 13 における各数字の逆元は以下である (= は合同記号の代わり)
//
//   1 *  1 = 1 (mod 13) より 1**-1 = 1
//   2 *  7 = 1 (mod 13) より 2**-1 = 7
//   3 *  9 = 1 (mod 13) より 3**-1 = 9
//   4 * 10 = 1 (mod 13) より 4**-1 = 10
//   5 *  8 = 1 (mod 13) より 5**-1 = 8
//
ll modinv(ll a, ll m) {
  ll b = m;
  ll u = 1;
  ll v = 0;

  while (b) {
    ll t = a / b;
    a = a - (t * b);
    swap(a, b);
    u = u - (t * v);
    swap(u, v);
  }
  u = u % m;
  if (u < 0) u += m;
  return u;
}

// a / b mod P の計算を、b の逆元を用いて a * b**-1 mod P で行う
int main() {
  const int MOD = 1000000007;
  ll a = 12345678900000;
  ll b = 100000;

  // 以下の式は a / b (mod 1e9+7) を計算している
  //
  // (a mod 1e9+7) / b を行うと、最終的な余りの数が、計算の順番によって変わってしまう。
  // そのため、b の逆元 (b**-1) を用いる。
  //
  // (a mod 1e9+7) * (b**-1) は mod p の掛け算であるため、
  // 計算の順番によって最終的な余りの数が変わらない。
  //
  // なお、mod p での b の逆元である b**-1 は modinv で算出している。

  // a / b (mod p) について「最後に余りを取る」場合と同じ結果を算出する
  //
  // a を 1000000007 で割ってから b の逆元をかけて計算
  a = a % MOD;
  cout << a * modinv(b, MOD) % MOD << endl;
  cout << b << endl;
  cout << MOD << endl;
  cout << modinv(b, MOD) << endl;
  return 0;
}
